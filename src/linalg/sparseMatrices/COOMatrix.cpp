#include <FastFem/linalg/sparseMatrices/COOMatrix.hpp>

#include <random>

namespace fastfem{
namespace linalg{

COOMatrix::COOMatrix(size_t n_rows, size_t n_cols, size_t nnz_hint) : SparseMatrix(n_rows, n_cols) {
    row_indices.reserve(nnz_hint);
    col_indices.reserve(nnz_hint);
    values.reserve(nnz_hint);
}

const double &COOMatrix::get_entry(size_t i, size_t j) const {

    static double dummy = 0.0;

    for(size_t k = 0; k < nnz(); ++k){
        if(row_indices[k] == i && col_indices[k] == j){
            return values[k];
        }
    }   
    
    return dummy;
}

Vector COOMatrix::gemv(const Vector& x) const{

    if(n_cols != x.size()){
        throw std::invalid_argument("COOMatrix::gemv(): incompatible dimensions");
    }

    Vector y(n_rows);

    for(size_t k = 0; k < nnz(); ++k){
        y[row_indices[k]] += values[k] * x[col_indices[k]];
    }
    return y;
}

void COOMatrix::add_entry(size_t i, size_t j, double value){
    if(!check_bounds(i, j)){
        throw std::out_of_range("COOMatrix::add_entry(): index out of range");
    }
    row_indices.push_back(i);
    col_indices.push_back(j);
    values.push_back(value);
}

COOMatrix COOMatrix::random(size_t n_rows, size_t n_cols, double sparsity, double min_value, double max_value, bool upper_triangular)
{
    if(sparsity < 0.0 || sparsity > 1.0){
        throw std::invalid_argument("COOMatrix::random(): invalid sparsity");
    }

    COOMatrix A(n_rows, n_cols);

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> sparsity_dis(0.0, 1.0);
    std::uniform_real_distribution<double> entry_dis(min_value, max_value);

    size_t nnz_hint = static_cast<size_t>(sparsity * n_rows * n_cols);
    COOMatrix B(n_rows, n_cols, nnz_hint);

    for(size_t i = 0; i < n_rows; ++i){
        size_t j_start = upper_triangular ? i : 0;
        for(size_t j = j_start; j < n_cols; ++j){
            if(sparsity_dis(gen) < sparsity){
                B.row_indices.push_back(i);
                B.col_indices.push_back(j);
                B.values.push_back(entry_dis(gen));
            }
        }
    }

    return B;
}

CSRMatrix COOMatrix::to_CSR() const
{

    std::cout << "COOMatrix::to_CSR(): this function assumes that the entries are sorted row-wise with no duplicates, as in the case of a matrix generated by COOMatrix::random()" << std::endl;

    if(nnz() == 0){
        std::vector<size_t> row_ptr(n_rows + 1, 0);
        CSRPattern pattern(row_ptr, {});
        return CSRMatrix(n_cols, pattern);
    }

    std::vector<size_t> csr_row_ptr(n_rows + 1, 0);
    std::vector<size_t> csr_col_indices;

    size_t current_row;

    for(size_t curr = 0; curr < nnz();){
        current_row = row_indices[curr];
        size_t j;
        for(j = curr; j < nnz() && row_indices[j] == current_row; ++j){
            csr_col_indices.push_back(col_indices[j]);
            ++curr;
            csr_row_ptr[current_row + 1]++;
        }
    }
    // cumulative sum
    size_t sum = 0;
    for(size_t i = 0; i < csr_row_ptr.size(); ++i){
        sum += csr_row_ptr[i];
        csr_row_ptr[i] = sum;
    }
    
    CSRPattern pattern(csr_row_ptr, csr_col_indices);
    CSRMatrix A(n_cols, pattern);

    for(size_t k = 0; k < nnz(); ++k){
        A.add_entry(k, values[k]);
    }

    return A;

}
void COOMatrix::print_pattern() const
{
    for(size_t i = 0; i < n_rows; ++i){
        for(size_t j = 0; j < n_cols; ++j){
            bool found = false;
            for(size_t k = 0; k < nnz(); ++k){
                if(row_indices[k] == i && col_indices[k] == j){
                    std::cout << "X";
                    found = true;
                    break;
                }
            }
            if(!found){
                std::cout << "O";
            } 
        }
        std::cout << std::endl;
    }
}

} // namespace linalg
} // namespace FastFem