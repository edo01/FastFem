#include <FastFem/linalg/sparseMatrices/COOMatrix.hpp>

#include <random>

namespace fastfem{
namespace linalg{

using types::ff_index;

COOMatrix::COOMatrix(ff_index n_rows, ff_index n_cols, ff_index nnz_hint) : SparseMatrix(n_rows, n_cols) {
    row_indices.reserve(nnz_hint);
    col_indices.reserve(nnz_hint);
    values.reserve(nnz_hint);
}

const double &COOMatrix::get_entry(ff_index i, ff_index j) const {

    static double dummy = 0.0;

    for(ff_index k = 0; k < nnz(); ++k){
        if(row_indices[k] == i && col_indices[k] == j){
            return values[k];
        }
    }

    return dummy;
    
}

void COOMatrix::operator=(const double& value){

    std::fill(values.begin(), values.end(), value);
}

Vector COOMatrix::gemv(const Vector& x) const{

    if(n_cols != x.size()){
        throw std::invalid_argument("COOMatrix::gemv(): incompatible dimensions");
    }

    Vector y(n_rows);

    for(ff_index k = 0; k < nnz(); ++k){
        y[row_indices[k]] += values[k] * x[col_indices[k]];
    }
    return y;
}

void COOMatrix::set_entry(ff_index i, ff_index j, double value){

    row_indices.push_back(i);
    col_indices.push_back(j);
    values.push_back(value);
}

COOMatrix COOMatrix::random(ff_index n_rows, ff_index n_cols, double sparsity, double min_value, double max_value, bool upper_triangular)
{
    if(sparsity < 0.0 || sparsity > 1.0){
        throw std::invalid_argument("COOMatrix::random(): invalid sparsity");
    }

    COOMatrix A(n_rows, n_cols);

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> sparsity_dis(0.0, 1.0);
    std::uniform_real_distribution<double> entry_dis(min_value, max_value);

    ff_index nnz_hint = static_cast<ff_index>(sparsity * n_rows * n_cols);
    COOMatrix B(n_rows, n_cols, nnz_hint);

    for(ff_index i = 0; i < n_rows; ++i){
        ff_index j_start = upper_triangular ? i : 0;
        for(ff_index j = j_start; j < n_cols; ++j){
            if(sparsity_dis(gen) < sparsity){
                B.row_indices.push_back(i);
                B.col_indices.push_back(j);
                B.values.push_back(entry_dis(gen));
            }
        }
    }

    return B;
}

CSRMatrix COOMatrix::to_CSR() const
{

    std::cout << "COOMatrix::to_CSR(): this function assumes that the entries are sorted row-wise with no duplicates, as in the case of a matrix generated by COOMatrix::random()" << std::endl;

    if(nnz() == 0){
        std::vector<ff_index> row_ptr(n_rows + 1, 0);
        CSRPattern pattern(row_ptr, {});
        return CSRMatrix(n_cols, pattern);
    }

    std::vector<ff_index> csr_row_ptr(n_rows + 1, 0);
    std::vector<ff_index> csr_col_indices;

    ff_index current_row;

    for(ff_index curr = 0; curr < nnz();){
        current_row = row_indices[curr];
        ff_index j;
        for(j = curr; j < nnz() && row_indices[j] == current_row; ++j){
            csr_col_indices.push_back(col_indices[j]);
            ++curr;
            csr_row_ptr[current_row + 1]++;
        }
    }
    // cumulative sum
    ff_index sum = 0;
    for(ff_index i = 0; i < csr_row_ptr.size(); ++i){
        sum += csr_row_ptr[i];
        csr_row_ptr[i] = sum;
    }
    
    CSRPattern pattern(csr_row_ptr, csr_col_indices);
    CSRMatrix A(n_cols, pattern);

    for(ff_index k = 0; k < nnz(); ++k){
        A.values[k] = values[k];
    }

    return A;

}

void COOMatrix::print_pattern() const
{
    for(ff_index i = 0; i < n_rows; ++i){
        for(ff_index j = 0; j < n_cols; ++j){
            bool found = false;
            for(ff_index k = 0; k < nnz(); ++k){
                if(row_indices[k] == i && col_indices[k] == j){
                    std::cout << "X";
                    found = true;
                    break;
                }
            }
            if(!found){
                std::cout << "O";
            } 
        }
        std::cout << std::endl;
    }
}

} // namespace linalg
} // namespace FastFem